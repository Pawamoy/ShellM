#!/bin/bash

## @file doxyman
## @brief generates man pages for library functions

## @desc This script lets you write some doxygen documentation in your
## library files and uses doxygen to parse them and generate a man page.
## The idea is to generate man pages for each file in your library.
##
## As you cannot use /** to comment a line in a
## shell script, you will have to use ## instead.
## A line beginning with more than 2 consecutive # will not be
## recognize as a documentation line.
##
## For example, if you have a library file include.sh containing a function
## called include, you can write above this function the following lines:
##
##     ## @fn int include (filename)
##     ## @brief Includes content of a library file in the current shell
##     ## @param $1 Names of library files to include
##     ## @return Code: 1 (and exits if subshell) if no args or error while including contents, 0 otherwise
##     ## @return Echo: message on stderr if return code 1
##
## The @fn line is optionnal but it lets you give a more precise prototype.
##
## If the shellm variable is defined in your
## current shell, the generated man page will be moved into the
## $shellm/man/man3 directory. You will then be able to type
## 'man include' to see the man page.

## @author Timothée Mazzucotelli <timothee.mazzucotelli@gmail.com>
## @package doxygen grep sed coreutils
## @env shellm Root directory of the shellm structure
## @seealso doxygen shelp
## @todo rajouter quand même le traitement de la balise package (et todo?)
## @todo reprendre le fonctionnement de shelp et l'appliquer ici (plus besoin de doxygen)

include message.sh
include check.sh
include usage.sh

check; [ $# -eq 0 ] && usage

isComment()              {
  echo "$1" | grep -q -e '^##[^#].*$' -e '^##$'
}

isCommentWithBalise()    {
  echo "$line" | grep -iq '^##[ ]*@[a-z]* .*$'
}

isFunction()             {
  (echo "$1" | grep -iq '^[a-z_]\w*[ ]*()[ ]*[{]') ||
    (echo "$1" | grep -iq 'function [ ]*[a-z_]\w* [{]')
}

isFnBalise()             {
  echo "$1" | grep -iq ' @fn '
}

getPrototype()           {
  echo "$1{}" | sed 's/^##[ ]*@fn //'
}

getFunctionName()        {
  echo "$1"                |\
  sed 's/^[ ]*function //' |\
  sed 's/[ ]*[{]//'        |\
  grep -io '^\w*'
}

getFunctionNameFromDoc() {
  echo "$1"         |\
  sed 's/[ ]*(.*//' |\
  sed 's/^.* //'
}

addFunctionToList()      {
  FN_LIST="$(getFunctionNameFromDoc "$1") $FN_LIST"
}

functionListed()         {
  echo "$FN_LIST" | grep -q "$(getFunctionName "$1")"
}

replaceOpen()            {
  echo "$1" | sed 's/^##[ ]*@/\/\*\* @/'
}

replaceMiddle()          {
  echo "$1" | sed 's/^##[ ]*/ \*  /'
}

replaceFunction()        {
  echo "int $(getFunctionName "$1")() {}"
}

progress()               {
  local val=$(( ($1*100)/$2 ))
  printf "\rParsing %-25s: %d%%" "$FILE" "$val" >&2
}

filter()                 {
    local FILTER1='^[ ]*[a-z_]\w*[ ]*([ ]*)[ ]*[{].*$'
    local FILTER2='^[ ]*function [a-z_]\w*[ ]*[{].*$'
    local FILTER3='^[ ]*##[ ]*.*$'
    local FILTER4='^[ ]*$'
    local FILTER
    /bin/cat "$1" | expand -t2 | /bin/grep -ie "$FILTER1" -e "$FILTER2" -e "$FILTER3" -e "$FILTER4"
}

parser()                 {
  # FIXME: can be optimized with //! instead of opening and closing /* * */
  local OPENED=false FN_LIST i=0
  while read line; do
    if isFunction "$line"; then
      $OPENED && { echo " */"; OPENED=false; }
      functionListed "$line" || replaceFunction "$line"
    elif isCommentWithBalise "$line"; then
      if $OPENED; then
        replaceMiddle "$line"
      else
        if isFnBalise "$line"; then
          getPrototype "$line"
          addFunctionToList "$line"
        fi
        replaceOpen "$line"
        OPENED=true
      fi
    elif isComment "$line"; then
      $OPENED && replaceMiddle "$line"
    else
      $OPENED && { echo " */"; OPENED=false; }
    fi
    progress $((++i)) $1 >&2
  done
  echo -n ". " >&2
  $OPENED && echo " */"
}

doxconf()                {
  echo "PROJECT_NAME = \"$FILE\""
  echo "INPUT = /tmp/$FILE"
  echo "GENERATE_MAN = YES"
  echo "GENERATE_HTML = NO"
  echo "GENERATE_LATEX = NO"
  echo "WARNINGS = NO"
  echo "WARN_IF_DOC_ERROR = NO"
  echo "WARN_IF_UNDOCUMENTED = NO"
  echo "FULL_PATH_NAMES = NO"
  echo "OUTPUT_DIRECTORY = /tmp"
}

main()                   {
  case $1 in
    ## @option -h, --help
    ## Print this help and exit
    -h|--help) shelp -t "$0"; exit 0 ;;
  esac

  [ ! -f "$1" ] && die "doxyman: $1: no such file or directory"
  local FILE LEN FILTERED
  while [ $# -ne 0 ]; do
    FILE="$(basename "$1")"
    FILTERED=$(filter "$1")
    LEN=$(echo "$FILTERED" | wc -l)
    echo "$FILTERED" | parser $LEN > "/tmp/$FILE"
    doxygen -g /tmp/doxyfile > /dev/null
    doxconf >> /tmp/doxyfile
    printf "Generating man page... "
    doxygen /tmp/doxyfile > /dev/null
    echo "done"
    /bin/rm "/tmp/$FILE" /tmp/doxyfile
    shift
  done
  /bin/rm /tmp/man/man3/_tmp_.3
  if [ -n "$shellm" ]; then
    echo -n "Moving manpage(s) to $shellm/man/man3... "
    for FILE in /tmp/man/man3/*.3; do
      [ ! -f "$FILE" ] && break
      chmod 664 "$FILE"
      /bin/mv "$FILE" "$shellm/man/man3/$(basename "${FILE%%.*}").3"
    done
    echo "done"
    echo -n "Cleaning up... "
    /bin/rm -rf /tmp/man
    echo "done"
  else
    echo "Manpage(s) are in /tmp/man/man3"
  fi
}

## @synopsis FILE [FILE...]
main "$@"
